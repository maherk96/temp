```java
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.MethodSource;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.lang.reflect.Method;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

class DisplayNameResolverTest {

    @Mock
    private ExtensionContext context;

    private YourExtensionClass extension; // Replace with your actual class name

    @org.junit.jupiter.api.BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        extension = new YourExtensionClass();
    }

    // SCENARIO 1: Simple @Test with no @DisplayName
    @Test
    void shouldReturnAutoGeneratedName_WhenTestHasNoDisplayName() throws Exception {
        // Given
        String methodName = "testUserAttemptsToTradeUnsupportedCurrencyPair";
        String rawDisplayName = "testUserAttemptsToTradeUnsupportedCurrencyPair";
        Method method = getMethodByName("testWithoutDisplayName");
        
        when(context.getTestMethod()).thenReturn(Optional.of(method));

        // When
        String result = extension.resolveDisplayName(context, methodName, rawDisplayName);

        // Then
        assertEquals(rawDisplayName, result);
    }

    // SCENARIO 2: Simple @Test with @DisplayName
    @Test
    void shouldReturnDisplayNameAnnotation_WhenTestHasDisplayName() throws Exception {
        // Given
        String methodName = "testUserAttemptsToTradeUnsupportedCurrencyPair1";
        String rawDisplayName = "Trade placement for an unsupported symbol";
        Method method = getMethodByName("testWithDisplayName");
        
        when(context.getTestMethod()).thenReturn(Optional.of(method));

        // When
        String result = extension.resolveDisplayName(context, methodName, rawDisplayName);

        // Then
        assertEquals("Trade placement for an unsupported symbol", result);
    }

    // SCENARIO 3: Parameterized test with @DisplayName but ugly toString
    @Test
    void shouldReturnDisplayNameAnnotation_WhenParameterizedTestHasDisplayNameAndUglyToString() throws Exception {
        // Given
        String methodName = "testPlaceMultipleTradesSuccessfully";
        String rawDisplayName = "[1] com.citi.fx.qa.junit.TradeServiceTest$TradeInfo@271f18d3";
        Method method = getMethodByName("parameterizedWithDisplayNameUglyToString");
        
        when(context.getTestMethod()).thenReturn(Optional.of(method));

        // When
        String result = extension.resolveDisplayName(context, methodName, rawDisplayName);

        // Then
        // Should use @DisplayName annotation, NOT the ugly auto-generated name
        assertEquals("Multiple trades are placed successfully", result);
    }

    // SCENARIO 4: Parameterized test with @DisplayName and good parameters
    @Test
    void shouldReturnDisplayNameAnnotation_WhenParameterizedTestHasDisplayNameAndCsvSource() throws Exception {
        // Given
        String methodName = "booker_flow";
        String rawDisplayName = "[1] ATM, SMARTTRADE_LO_NAM1, GBP, GBPUSD, SELL, 1.2342, TRM_TRADE1";
        Method method = getMethodByName("parameterizedWithDisplayNameAndCsv");
        
        when(context.getTestMethod()).thenReturn(Optional.of(method));

        // When
        String result = extension.resolveDisplayName(context, methodName, rawDisplayName);

        // Then
        // Should use @DisplayName annotation
        assertEquals("Send execution report to agg booker and verify FXPG request/response", result);
    }

    // SCENARIO 5: Parameterized test WITHOUT @DisplayName (auto-generated pattern)
    @Test
    void shouldReturnAutoGeneratedPattern_WhenParameterizedTestHasNoDisplayName() throws Exception {
        // Given
        String methodName = "testMultipleTrades";
        String rawDisplayName = "testMultipleTrades() [1]";
        Method method = getMethodByName("parameterizedWithoutDisplayName");
        
        when(context.getTestMethod()).thenReturn(Optional.of(method));

        // When
        String result = extension.resolveDisplayName(context, methodName, rawDisplayName);

        // Then
        // Should keep the auto-generated pattern
        assertEquals(rawDisplayName, result);
    }

    // SCENARIO 6: Parameterized test with custom name but no @DisplayName
    @Test
    void shouldReturnMethodName_WhenParameterizedTestHasCustomNameButNoDisplayName() throws Exception {
        // Given
        String methodName = "testTrades";
        String rawDisplayName = "Trade 1: EURUSD";
        Method method = getMethodByName("parameterizedWithCustomNameNoDisplayName");
        
        when(context.getTestMethod()).thenReturn(Optional.of(method));

        // When
        String result = extension.resolveDisplayName(context, methodName, rawDisplayName);

        // Then
        // Falls back to method name since it's not auto-generated and has no @DisplayName
        assertEquals(methodName, result);
    }

    // SCENARIO 7: Method is empty (edge case)
    @Test
    void shouldReturnRawDisplayName_WhenMethodIsEmpty() throws Exception {
        // Given
        String methodName = "testMethod";
        String rawDisplayName = "[1] argument";
        
        when(context.getTestMethod()).thenReturn(Optional.empty());

        // When
        String result = extension.resolveDisplayName(context, methodName, rawDisplayName);

        // Then
        assertEquals(rawDisplayName, result);
    }

    // SCENARIO 8: @DisplayName takes priority even if rawDisplayName is auto-generated
    @Test
    void shouldAlwaysPrioritizeDisplayNameAnnotation_EvenWithAutoGeneratedPattern() throws Exception {
        // Given
        String methodName = "testSomething";
        String rawDisplayName = "testSomething()"; // auto-generated
        Method method = getMethodByName("testWithDisplayName");
        
        when(context.getTestMethod()).thenReturn(Optional.of(method));

        // When
        String result = extension.resolveDisplayName(context, methodName, rawDisplayName);

        // Then
        // @DisplayName should win even though rawDisplayName is auto-generated
        assertEquals("Trade placement for an unsupported symbol", result);
    }

    private Method getMethodByName(String name) throws NoSuchMethodException {
        return TestMethods.class.getDeclaredMethod(name);
    }

    // Test methods representing different user scenarios
    static class TestMethods {
        // Scenario 1
        @Test
        void testWithoutDisplayName() {}

        // Scenario 2
        @Test
        @DisplayName("Trade placement for an unsupported symbol")
        void testWithDisplayName() {}

        // Scenario 3
        @ParameterizedTest
        @MethodSource("tradeDataProvider")
        @DisplayName("Multiple trades are placed successfully")
        void parameterizedWithDisplayNameUglyToString(TradeInfo tradeInfo) {}

        // Scenario 4
        @ParameterizedTest
        @CsvSource({
            "ATM,SMARTTRADE_LO_NAM1,GBP,GBPUSD,SELL,1.2342,TRM_TRADE1"
        })
        @DisplayName("Send execution report to agg booker and verify FXPG request/response")
        void parameterizedWithDisplayNameAndCsv(String p1, String p2, String p3, 
                                                 String p4, String p5, String p6, String p7) {}

        // Scenario 5
        @ParameterizedTest
        @MethodSource("tradeDataProvider")
        void parameterizedWithoutDisplayName(TradeInfo tradeInfo) {}

        // Scenario 6
        @ParameterizedTest(name = "Trade {index}: {0.instrument}")
        @MethodSource("tradeDataProvider")
        void parameterizedWithCustomNameNoDisplayName(TradeInfo tradeInfo) {}
    }

    // Mock TradeInfo class
    static class TradeInfo {
        String instrument;
        int quantity;
    }
}

```
